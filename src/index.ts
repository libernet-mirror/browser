import fs from "node:fs/promises";
import path from "node:path";

import {
  app,
  BaseWindow,
  BrowserWindow,
  ipcMain,
  WebContentsView,
} from "electron";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const INITIAL_WIDTH = 800;
const INITIAL_HEIGHT = 600;
const CONTROL_BAR_HEIGHT = 50;

const SYSTEM_URL_WALLET = "liber://wallet";

const DEFAULT_HOME_ADDRESS = "https://google.com";

const URL_PROTOCOL_PATTERN = /^([a-z]+):\/\//;

const createWindow = async () => {
  const mainWindow = new BaseWindow({
    title: "Libernet",
    width: INITIAL_WIDTH,
    height: INITIAL_HEIGHT,
  });
  mainWindow.setMenu(null);

  const controlBar = new WebContentsView({
    webPreferences: {
      contextIsolation: true,
      devTools: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });
  controlBar.setBackgroundColor("#0fff");
  controlBar.setBounds({
    x: 0,
    y: 0,
    width: INITIAL_WIDTH,
    height: CONTROL_BAR_HEIGHT,
  });
  controlBar.webContents.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  let viewType: "web" | "system" = "web";
  let currentView: WebContentsView | null = null;
  let currentUrl = DEFAULT_HOME_ADDRESS;

  const setSystemView = async () => {
    if (viewType !== "system") {
      if (currentView) {
        currentView.removeAllListeners();
        mainWindow.contentView.removeChildView(currentView);
        currentView = null;
      }
      viewType = "system";
    }
    if (!currentView) {
      currentView = new WebContentsView({
        webPreferences: {
          contextIsolation: true,
          devTools: false,
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
      });
      const { width, height } = mainWindow.getBounds();
      currentView.setBounds({
        x: 0,
        y: CONTROL_BAR_HEIGHT,
        width,
        height: height - CONTROL_BAR_HEIGHT,
      });
      mainWindow.contentView.addChildView(currentView);
      mainWindow.contentView.addChildView(controlBar);
    }
    currentUrl = SYSTEM_URL_WALLET;
    controlBar.webContents.send("root/url", currentUrl);
    await currentView.webContents.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  };

  const setWebView = async (url: string) => {
    if (!URL_PROTOCOL_PATTERN.test(url)) {
      url = "http://" + url;
    }
    {
      const [, protocol] = url.match(URL_PROTOCOL_PATTERN);
      if (protocol !== "http" && protocol !== "https") {
        throw new Error(`invalid protocol "${protocol}"`);
      }
    }
    if (viewType !== "web") {
      if (currentView) {
        currentView.removeAllListeners();
        mainWindow.contentView.removeChildView(currentView);
        currentView = null;
      }
      viewType = "web";
    }
    if (!currentView) {
      currentView = new WebContentsView({
        webPreferences: {
          contextIsolation: true,
          devTools: true,
        },
      });
      const { width, height } = mainWindow.getBounds();
      currentView.setBounds({
        x: 0,
        y: CONTROL_BAR_HEIGHT,
        width,
        height: height - CONTROL_BAR_HEIGHT,
      });
      currentView.webContents
        .on("will-navigate", ({ url }) => {
          controlBar.webContents.send("root/url", (currentUrl = url));
        })
        .on("did-navigate-in-page", (_, url) => {
          controlBar.webContents.send("root/url", (currentUrl = url));
        });
      mainWindow.contentView.addChildView(currentView);
      mainWindow.contentView.addChildView(controlBar);
    }
    currentUrl = url;
    controlBar.webContents.send("root/url", currentUrl);
    await currentView.webContents.loadURL(currentUrl);
  };

  ipcMain.handle("root/get-view", async ({ sender }) => {
    switch (sender) {
      case controlBar.webContents:
        return "control";
      case currentView?.webContents:
        return viewType;
      default:
        throw new Error();
    }
  });

  ipcMain.handle("root/get-url", async () => currentUrl);

  ipcMain.handle("root/set-url", async (_, url: string) => {
    switch (url) {
      case SYSTEM_URL_WALLET:
        await setSystemView();
        break;
      default:
        await setWebView(url);
        break;
    }
  });

  ipcMain.handle("root/refresh", () => {
    currentView?.webContents.reload();
  });

  mainWindow.on("resize", () => {
    const { width, height } = mainWindow.getBounds();
    controlBar.setBounds({ x: 0, y: 0, width, height: CONTROL_BAR_HEIGHT });
    currentView?.setBounds({
      x: 0,
      y: CONTROL_BAR_HEIGHT,
      width,
      height: height - CONTROL_BAR_HEIGHT,
    });
  });

  await setWebView(currentUrl);
};

// This method will be called when Electron has finished initialization and is ready to create
// browser windows. Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common for applications and their
// menu bar to stay active until the user quits explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the dock icon is clicked and there
  // are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process code. You can also put
// them in separate files and import them here.

import { Libernet } from "./libernet";
import { Mutex } from "./mutex";
import { Wallet, WalletData } from "./wallet";

const walletFileMutex = new Mutex();

let _libernet: Libernet | null = null;

function getWalletPath(): string {
  return path.join(app.getPath("userData"), "wallet.json");
}

function libernet(): Libernet {
  if (_libernet) {
    return _libernet;
  } else {
    throw new Error("not connected");
  }
}

ipcMain.handle("wallet/get-status", async () => {
  if (Wallet.isLoaded()) {
    return "loaded";
  }
  try {
    await fs.stat(getWalletPath());
    return "stored";
  } catch {
    return "none";
  }
});

ipcMain.handle("wallet/create", async (_, passwords: string[]) => {
  const wallet = await Wallet.create(passwords);
  const data: WalletData = {
    version: "1.0",
    num_kdf_rounds: Wallet.NUM_KDF_ROUNDS,
    salt: wallet.salt,
    seed: wallet.seed,
    c: wallet.commitment,
    y: wallet.proofs,
  };
  const path = getWalletPath();
  const text = JSON.stringify(data, null, 2);
  await walletFileMutex.locked(async () => {
    await fs.writeFile(path, text);
  });
  console.log(`${path} written`);
});

ipcMain.handle("wallet/load", async (_, password: string) => {
  const path = getWalletPath();
  console.log(`reading ${path}`);
  const data = (await walletFileMutex.locked(() => fs.readFile(path))).toString(
    "utf-8",
  );
  const wallet = await Wallet.load_v1_0(
    JSON.parse(data) as WalletData,
    password,
  );
  const account = wallet.getAccountByNumber(0);
  try {
    _libernet = await Libernet.create(account);
  } catch (error) {
    console.error(error);
  }
  return true;
});

ipcMain.handle("wallet/get-account-by-number", async (_, index: number) => {
  return Wallet.get().getAccountByNumber(index).address();
});

ipcMain.handle("account/get-balance", async (_, address: string) => {
  return await libernet().getBalance(address);
});
